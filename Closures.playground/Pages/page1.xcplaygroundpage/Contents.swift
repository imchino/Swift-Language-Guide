//: [Previous](@previous)
/*:
 # Closures
 クロージャーは自己完結型の機能ブロックであり、関数をコードに渡して使用できます。
 Swiftのクロージャーは、CおよびObjective-Cのブロック、および他のプログラミング言語のラムダに似ています。

 クロージャは、「定義したコンテキスト」から「任意の定数および変数」への参照をキャプチャおよび保存できます。
 これは、定数と変数のClosing-overとして知られています。
 Swiftは、キャプチャ内容のメモリ管理を全て処理します。
*/
/*:
 __`NOTE`__\
 キャプチャの概念については、[Capturing Values](https://docs.swift.org/swift-book/LanguageGuide/Closures.html#ID103)を参照してください。
*/
/*:
 関数で紹介したグローバル関数とネスト関数は、実際にはクロージャーの特別なケースです。
 クロージャーは、次の3つの形式のいずれかを取ります。

 - グローバル関数は名前を持ち、値をキャプチャしないクロージャー
 - ネスト関数は、名前を持ち、それを囲む関数から値をキャプチャできるクロージャー
 - 周囲のコンテキストから値をキャプチャできる軽量の構文で記述された無名クロージャー

 Swiftのクロージャーは一般的な用途において、簡潔で整理された構文を推奨することで最適化され、クリーンで明確なスタイルになります。
 これらの最適化には以下が含まれます。

 - コンテキストからパラメータと戻り値の型を推論する
 - 単行クロージャーからは暗黙的に値を返す
 - 引数名の省略記法
 - 末尾のクロージャー Trailing-cloture 構文
 */
/*:
 ## Closure Expressions
 __`クロージャーの記述式`__\
 より大きな関数の一部として自己完結型のコードブロックを命名および定義する便利な手段として、ネスト関数がありました。
 しかしながら、完全な宣言と名前がない構造の、関数を短くしたようなものを作成したい場合があります。
 特に、「引数として関数をいくつか受け取る」関数またはメソッドを使用する場合のことです。

 クロージャーは、簡潔で焦点を絞った構文でインラインクロージャを記述します。
 明快さや意図を見失うことがないよう手短に記述するために、クロージャ構文を最適化できます。
 以下で、これらの最適化を説明するため sorted(by:)メソッドを例にします。
 各反復は同じ機能をより簡潔に表現します。
*/
/*:
 ### The Sorted Method
 Swift標準ライブラリには、`sorted(by:)`メソッドがあります。
 このメソッドは、指定した順に並べ替えるクロージャー出力に基づいて、配列をソートします。
 ソートプロセスが完了すると、`sorted(by:)`メソッドは「型およびサイズが元の配列と同じ」新しい配列を返します。
 新しい配列の要素は正しく並び替えられた順になります。
 元の配列が`sorted(by:)`メソッドによって変更されることはありません。

 以下のクロージャー式の例では、`sorted(by:)`メソッドを使用して、文字列値の配列をアルファベット逆順に並べ替えます。
 並べ替えられる最初の配列は次のとおりです。
 
 ````
 let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
 ````
 */
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

/*:
 `sort(by:)`メソッドは...
 - 配列のコンテンツと同じ型の2つの引数があるクロージャーを受け取る
 - 値が並べ替えられると、最初の値が次の値の「前に現れるか、後に現れるか」を示す`Bool`値を返す

 並べ替えクロージャーの要件は以下の通りです。
 最初の値が、次の値の...
 - 前に表示される場合 → `true`を返す
 - 後に表示される場合 → `false`を返す

 この例では、文字列値の配列を並べ替えています。
 そのため、並べ替えクロージャは`(String, String）-> Bool`型になります。

 並べ替えクロージャを提供するには、「適切な型の関数を記述し、それを引数として`sort(by:)`メソッドに渡す方法があります。
 
 ````
 func backward(_ s1: String, _ s2: String) -> Bool {
    return s1 > s2
 }
 
 var reversedNames = names.sorted(by: backward)
 // reversedNames is equal to ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
 ````
 */
func backward(_ s1: String, _ s2: String) -> Bool {
   return s1 > s2
}
var reversedNames = names.sorted(by: backward)

/*:
 最初の文字列`s1`が2番目の文字列`s2`よりも大きい場合、`backward(_:_ :)`関数は`true`を返し、ソートされた配列で`s1`が`s2`の前に現れます。
 文字の場合、「より大きい」は「アルファベットの後半である」ことを意味します。
 これにより、「Barry」が「Alex」の前に配置されるなど、アルファベットの逆順に並べ替えられます。

 ただし、これは単行関数（`a> b`）を記述する方法としては冗長です。
 クロージャー式構文を使用して、並べ替えクロージャーをインラインで記述するほうが望ましいでしょう。
 */
/*:
 ### Closure Expression Syntax
 一般的なクロージャー式の構文は、次のとおりです。

 ````
 { (parameters) -> return type in
    statements
 }
 ````

 クロージャー式の構文のパラメーターは`in-out`パラメーターにすることができます。
 ただし、デフォルト値を持つことはできません。
 可変長パラメーターに名前を付けると、可変長パラメーターを使用できます。
 パラメーター型および戻り値型として、タプルも使用できます。

 以下の例は、上からのbackward（_：_ :)関数のクロージャー式バージョンを示しています。
 
 ````
 reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in
    return s1 > s2
 })
 ````
 */


//: [Next](@next)
